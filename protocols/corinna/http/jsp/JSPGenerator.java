package corinna.http.jsp;


import java.io.IOException;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;
import java.util.List;
import java.util.StringTokenizer;

import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;
import javassist.CtNewMethod;
import corinna.exception.JSPCompilerException;
import corinna.exception.JSPParserException;


public class JSPGenerator
{

	public static Class<?> compile( String pkgName, String className, Reader input )
		throws JSPCompilerException, JSPParserException, IOException
	{
		if (className == null || className.isEmpty()) return null;
		if (pkgName == null) pkgName = "";

		JSPParser parser = new JSPParser(input);
		parser.parse();
		GeneratorContext context = createContext(parser.elements);

		// write the 'render' method
		StringBuilder source = context.out;
		source.append(context.INDENTATION + context.RENDER_METHOD);
		source.append(context.INDENTATION + "{ ");
		for (JSPElement element : context.renderSegments)
			render(context, element);
		source.append(context.INDENTATION + "}");
		// create the imports array
		String imports[] = context.importList.split("[, \t\f\r\n]");
		
		return createRenderClass(className, source.toString(), imports);
	}

	private static Class<?> createRenderClass( String className, String renderCode, String[] imports ) throws JSPCompilerException
	{
		try
		{
			ClassPool pool = ClassPool.getDefault();
			if (pool == null) return null;
			
			// import all packages
			for (String item : imports) pool.importPackage(item);
			
			// create the class
			CtClass parent = pool.get(IServerPageRender.class.getName());
			CtClass newClass = pool.makeClass(className, parent);
			// create the "render" method
			CtMethod method = CtNewMethod.make(renderCode, newClass);
			newClass.addMethod(method);
			
			Class<?> result = newClass.toClass();
			newClass.detach();
			pool.clearImportedPackages();
			
			return result;
		} catch (Exception e)
		{
			throw new JSPCompilerException("Error compiling JSP", e);
		}
	}
	
	static public void translate( String pkgName, String className, Reader input, Writer output )
		throws IOException, JSPParserException
	{
		PrintWriter out = (output instanceof PrintWriter) ? (PrintWriter) output : new PrintWriter(
			output);

		JSPParser parser = new JSPParser(input);
		parser.parse();

		GeneratorContext context = createContext(parser.elements);

		// write some generator information
		out.println("/* The following code was generated by Corinna on "
			+ Calendar.getInstance().getTime() + " */");
		// write the class package
		if (pkgName != null) out.println("package " + pkgName + ";");
		out.println();
		// write the class imports
		if (context.importList != null)
		{
			StringTokenizer tknz = new StringTokenizer(context.importList, ", \t\f\r\n");
			while (tknz.hasMoreTokens())
				out.println("import " + tknz.nextToken() + ";");
			out.println();
		}
		// write the class header
		out.print("public class " + className);
		if (context.superClassName != null)
			out.println(" extends " + context.superClassName);
		else
			out.println();
		out.println("{");
		// write the declarations
		for (JSPElement decl : context.declarations)
			out.println(decl.content.toString());
		// write the 'render' method
		context.out.append(context.INDENTATION + context.RENDER_METHOD);
		context.out.append(context.INDENTATION + "{");
		for (JSPElement element : context.renderSegments)
			render(context, element);
		context.out.append(context.INDENTATION + "}");
		// write the class footer
		context.out.append("}");

		out.print(context.out.toString());
		out.close();
	}

	private static GeneratorContext createContext( List<JSPElement> elements )
		throws JSPParserException
	{
		GeneratorContext context = new GeneratorContext();

		for (JSPElement elem : elements)
		{
			switch (elem.type)
			{
				case JSPElement.TYPE_COMMENT:
					// nothing
					break;

				case JSPElement.TYPE_DECLARATION:
					context.declarations.add(elem);
					break;

				case JSPElement.TYPE_SCRIPTLET:
					context.renderSegments.add(elem);
					break;

				case JSPElement.TYPE_EXPRESSION:
					if (isBlank(elem.content))
						throw new JSPParserException("empty expression", elem.row, elem.col);
					context.renderSegments.add(elem);
					break;

				case JSPElement.TYPE_TEXT:
					context.renderSegments.add(elem);
					break;

				case JSPElement.TYPE_DIRECTIVE:
					if (!elem.directiveName.equals("page"))
						throw new JSPParserException("directive " + elem.directiveName
							+ " not supported", elem.row, elem.col);
					for (Iterator<String> ater = elem.directiveAttributes.keySet().iterator(); ater
						.hasNext();)
					{
						String attrName = (String) ater.next();
						String attrValue = (String) elem.getAttribute(attrName);
						if (attrName.equals("package"))
							context.pkgName = attrValue;
						else
							if (attrName.equals("extends"))
								context.superClassName = attrValue;
							else
								if (attrName.equals("import"))
									context.importList += " " + attrValue;
								else
									if (attrName.equals("render-method"))
										context.RENDER_METHOD = attrValue;
									else
										if (attrName.equals("text-wrapper"))
											context.TEXT_WRAPPER = attrValue;
										else
											if (attrName.equals("expr-wrapper"))
												context.EXPR_WRAPPER = attrValue;
											else
												if (attrName.equals("ws-gobbling"))
													context.WS_GOBBLING = attrValue.equals("true");
												else
													throw new JSPParserException(
														"page directive attribute " + attrName
															+ " not supported", elem.row, elem.col);
					}
					break;

				default:
					throw new JSPParserException("internal error, unknown segment type "
						+ elem.type, elem.row, elem.col);
			}
		}

		return context;
	}

	private static void render( GeneratorContext context, JSPElement elem )
	{
		switch (elem.type)
		{
			case JSPElement.TYPE_SCRIPTLET:
				context.out.append(elem.content.toString());
				break;

			case JSPElement.TYPE_EXPRESSION:
				context.out.append(context.INDENTATION + context.INDENTATION + context.TEXT_WRAPPER
					+ '(');
				context.out.append(context.EXPR_WRAPPER + '(' + elem.content + ')');
				context.out.append(");");
				break;

			case JSPElement.TYPE_TEXT:
				boolean gobbled = false;
				if (context.WS_GOBBLING && isBlank(elem.content))
				{
					char last = elem.content.charAt(elem.content.length() - 1);
					JSPElement porn = (last == '\r' || last == '\n') ? elem.prev : elem.next;
					gobbled = porn != null && porn.type != JSPElement.TYPE_TEXT
						&& porn.type != JSPElement.TYPE_EXPRESSION;
				}
				if (!gobbled)
				{
					context.out.append(context.INDENTATION + context.INDENTATION
						+ context.TEXT_WRAPPER + '(');
					context.out.append(toJavaStringLiteral(elem.content));
					context.out.append(");");
				}
				break;

			default:
				throw new Error("assertion error, not a render segment type " + elem.type);
		}

	}


	static boolean isBlank( StringBuffer buf )
	{
		for (int i = 0; i < buf.length(); i++)
		{
			if (!Character.isSpaceChar(buf.charAt(i))) return false;
		}
		return true;
	}

	static String toJavaStringLiteral( StringBuffer in )
	{
		StringBuffer out = new StringBuffer();
		out.append('"');
		for (int i = 0; i < in.length(); i++)
		{
			char c = in.charAt(i);
			switch (c)
			{
				case '\b':
					out.append("\\b");
					break;
				case '\t':
					out.append("\\t");
					break;
				case '\n':
					out.append("\\n");
					break;
				case '\f':
					out.append("\\f");
					break;
				case '\r':
					out.append("\\r");
					break;
				case '\"':
					out.append("\\\"");
					break;
				case '\\':
					out.append("\\");
					break;
				default:
					out.append(c);
			}
		}
		out.append('"');
		return out.toString();
	}

	protected static class GeneratorContext
	{

		public GeneratorContext()
		{
			this.out = new StringBuilder();
		}

		public StringBuilder out = null;

		public String pkgName;

		public String RENDER_METHOD = "public void render(java.io.PrintWriter out)";

		public String TEXT_WRAPPER = "out.print";

		public String EXPR_WRAPPER = "String.valueOf";

		public String INDENTATION = "\t";

		public boolean WS_GOBBLING = true;

		public String superClassName = null;

		public String importList = "";

		public List<JSPElement> declarations = new ArrayList<JSPElement>();

		public List<JSPElement> renderSegments = new ArrayList<JSPElement>();
	}

}
